---
layout: post
title: "0206：数据结构-大O表示法"
description: "大O表示法"
categories: [算法]
tags: [算法, 数据结构]
---

本文依照学习难度，分成入门、进阶两个部分。

入门部分以直观、易于理解为主；进阶部分重点在于概念、推导等。

# 目录

* Kramdown table of contents
{:toc .toc}

# 入门  

在使用算法时，总是会提及性能好、速度快，那么如何度量好与快呢？

> 使用 O(n)，n为操作数
> > 大O表示法让你能够比较操作数，它指出了算法运行时间的增速
>
> > 关键词：操作数、增速

比如，在查找算法里，同样是在N个数里查找元素

简单查找和二分查找有这样的差异

    |---------------------+------------+-----------------|
    |                        简单查找  |    二分查找     | 
    |---------------------|:-----------|:---------------:|
    | 100个元素           |   100毫秒  |     7毫秒       |
    | 10,000个元素        |   10秒     |     14毫秒      | 
    | 1000,000,000个元素  |   11天     |     32毫秒      |
    |---------------------+------------+-----------------|

可以看到随着元素个数的增加，差距越来越大。

有鉴于此，仅知道算法需要多长时间才能运行完毕还不够，还需要知道运行时间如何随列表增长而增加

> 特别注意的是，O(n)里面的n并不是指以秒为单位的速度，而是执行的操作数量。
> > 为啥是n次呢，也可能第一个就找到了，O(n)是按照最糟糕情形来计算的，也就是n个元素，最后一个才找到自己想要的

## O(n) 和 O(logn) 区别在哪里

![]({{ site.url }}/assets/shuzu_blog/bigO_01.jpg){:height="50%" width="50%"}

目前使用大O表示法，log指的都是log2

一些常见的大O运行时间
O(logn):对数时间，例如：二分查找
O(n):线性时间，例如：简单查找
O(nlogn):例如：快速排序
O(n^2):例如：选择排序
O(n!):例如：旅行商问题

看电话簿里每个人的名字，需要n次，只看其中的A开头，O(n)并不会变成O(n/26)，而依旧是O(n)

因为在很多情况下，常量无关紧要，比如

![]({{ site.url }}/assets/shuzu_blog/bigO_02.jpg){:height="50%" width="50%"}

但有时候，常量的影响很大，例如在快速查找、合并查找情形下。

# 进阶 

[^1]: 参考文献.
[1] 算法图解 Aditya Bhargava (作者) 袁国忠 (译者)