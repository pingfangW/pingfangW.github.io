---
layout: post
title: "第三篇：图"
description: "图"
categories: [算法]
tags: [算法, 图]
redirect_from:
  - /2018/10/06/
---

# 目录

* Kramdown table of contents
{:toc .toc}

# 正文

> 图由节点和边组成
> > 一个节点可能与众多节点直接相连，这些节点被称为邻居

![]({{ site.url }}/assets/shuzu_blog/graph_01.jpg){:height="50%" width="50%"}

# 图算法
## 一、广度优先搜索

> 是一种用于图数据的查找算法
>
> 用于解决两类问题
> > 第一类：从节点A出发，有前往节点B的路径吗
>
> > 第二类：从节点A出发，前往节点B的哪条路径最短

如何实现呢？

比如在上述A,B,C,D,E 构成的关系图中，想看A,E是否存在相通的道路，A,E如果相通，最短的路径是哪条。

让我们一度、二度依次来看（什么是一度、二度呢？我的朋友是一度，朋友的朋友是二度）

> A的一度朋友有B,C，添加到列单里 ==> {B,C}, B,C中都没有E, 因此接着看二度
> 
> B的一度朋友有D，添加到列表里 ==> {B,C,D}
>
> C的一度朋友有B,D，添加到列表里 ==> {B,C,D}
> 
> D的一度朋友有E， bingo

要用代码实现上述过程，首先应获取所有的关系数据，这种对应关系，散列表可以实现

	|--------+--------|
	|        |   B    |
	|    A   |--------|
	|        |   C    |
	|--------+--------|

~~~~~~~~~
graph = {}
graph['A']=['B','C']
graph['B']=['D']
graph['C']=['B','D']
graph['D']=['E']
graph['E']=[]
~~~~~~~~~

实现：通过构建一个搜索队列（补充）

运行时间：O(V+E)  （补充）

拓扑排序：（补充）

广度优先搜索指出是否有从A到B的路径，如果有，广度优先搜索将找出最短路径。

## 二、深度优先算法

## 三、狄克斯特拉算法

> 找出加权图中前往X的最短路径

前面是根据图中边的个数去判断路径长短，如果边是有权重的呢？（也就是广度优先搜索，找出的是段数最少的路径，如果要找出最快的路径呢）

例如在汽车行驶过程中，两点之间的时间长短会受到距离长短和拥堵程度影响，因此不同点之间应该有相应的权重赋值。

例如下图的区别：

![]({{ site.url }}/assets/shuzu_blog/graph_02.jpg){:height="50%" width="50%"}

狄克斯特拉找到的是总权重最小的路径。

狄克斯特拉算法包含4个步骤：

以下图为例：

![]({{ site.url }}/assets/shuzu_blog/graph_03.jpg){:height="50%" width="50%"}

1、找出“最便宜”的节点，即可在最短时间内到达的节点

站在七点，不知道应该往节点A还是往节点B。假设前往节点A要6分钟，前往B要2分钟。由于不知道前往终点需要多长时间，因此假设为无穷大。从这个角度考虑，节点B最近，选择节点B

2、更新该节点的邻居开销

从节点B出发，计算经节点B前往其各个邻居所需的时间。发现！经B节点，前往A节点，需要5分钟，而直接前往A节点需要6分钟！

对于节点B的邻居，如果找到前往它的最短路径，就更新其开销： 在这里发现：

~ 前往节点A的更短路径（时间从6分钟缩短到5分钟）

~ 前往终点的更短路径（时间从无穷大缩短到7分钟）

3、重复这个过程，直到对图中的每个节点都这样做了

重复第一步：终点最短时间内前往的节点。前面已经对节点B执行了第二步，除节点B外，可在最短时间内前往的节点是节点A

重复第二步：更新节点A的所有邻居开销。发现前往终点的时间为6分钟。？？？

到目前为止，已经知道：

> 前往节点B需要2分钟
> 
> 前往节点A需要5分钟
>
> 前往终点需要6分钟

4、计算最终路径


其他：

狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重。

带权重的图称为加权图。不带权重的图称为非加权图。

图还有环，如下图：

![]({{ site.url }}/assets/shuzu_blog/graph_04.jpg){:height="50%" width="50%"}

有环就意味着，可以从一个节点出发，走一圈后又回到这个节点，

绕环前行是否合理呢？你可以选择避开环的路径，也可以选择包含环的路径。

这两条路径都可以到达终点，但环增加了权重，如果愿意，可绕环两次。但每绕环一次，总权重都增加8。因此，绕环的路径不可能是最短的路径

无向图意味着两个节点彼此指向对方，其实就是环。

![]({{ site.url }}/assets/shuzu_blog/graph_05.jpg){:height="50%" width="50%"}

在无向图中，每一条边都是一个环，迪克斯拉特算法只适用于有向无环图（directed acyclic graph, DAG）

《算法图解》中换钢琴的例子，第101页。感觉上面四个步骤，写成列表更清楚

![]({{ site.url }}/assets/shuzu_blog/graph_06.jpg){:height="50%" width="50%"}

![]({{ site.url }}/assets/shuzu_blog/graph_07.jpg){:height="50%" width="50%"}

上面知道最短路径的开销是35美元，但是如何确定这条路径呢？

首先找出钢琴的父节点：是架子鼓，架子鼓的父节点是唱片，唱片的父节点是乐谱。

由此，可以知道完整的交换路径是：乐谱 ==> 唱片 ==> 架子鼓 ==> 钢琴

> 负权边

有可能存在下面这种情况：

![]({{ site.url }}/assets/shuzu_blog/graph_08.jpg){:height="50%" width="50%"}

也就是边的权重是负的！

如果有负权边，就不能使用狄克斯特拉算法。原因见《算法图解》107页

因为狄克斯特拉算法的一个假设是：对于处理过的海报节点，没有前往该节点的更短路径。这一点也体现出为什么一个一个选最便宜的节点，这样的顺序重要性。

## 代码实现：

以下图为例：

![]({{ site.url }}/assets/shuzu_blog/graph_09.jpg){:height="50%" width="50%"}

解决上图这个问题，需要三个散列表。随着算法的进行，将不断更新散列表【开销表】和【父节点表】。

![]({{ site.url }}/assets/shuzu_blog/graph_10.jpg){:height="50%" width="50%"}

先将上面的图关系存进散列表中去（散列表中又包含散列表）

~~~
graph = {}
graph["start"] = {}
graph["start"]["a"] = 6
graph["start"]["b"] = 2

graph["a"] = {}
graph["a"]["fin"] = 1

graph["b"] = {}
graph["b"]["a"] = 3
graph["b"]["fin"] = 5

graph["fin"] = {}
~~~

接下来建立一个散列表存储每个节点的开销

~~~
infinity = float("inf")
costs = {}
costs["a"] = 6
costs["b"] = 2
costs["fin"] = infinity
~~~

还需要一个存储父节点的散列表

~~~
parents = {}
parents["a"] = "start"
parents["b"] = "start"
parents["fin"] = None
~~~ 

最后，需要一个数组，用于记录处理过的节点。

因为对于同一个节点，不用处理多次。

~~~
processed = []
~~~

算法过程如下：

![]({{ site.url }}/assets/shuzu_blog/graph_11.jpg){:height="50%" width="50%"}

代码如下：

~~~
node = find_lowest_cost_node(costs)  # 在未处理的节点中找出开销最小的节点
while node is not None:			     # 这个while循环在所有节点都被处理后结束
	cost = costs[node]
	neighbors = graph[node]
	for n in neighbors.keys():  #遍历当前节点的所有邻居
		new_cost = cost + neighbors[n]
		if costs[n] = new_cost:
			cost[n] = new_cost
			parents[n] = node
	processed.append(node)
	node = find_lowest_cost_node(costs)
	








 


[^1]: 参考文献.
[1] 算法图解 Aditya Bhargava (作者) 袁国忠 (译者)