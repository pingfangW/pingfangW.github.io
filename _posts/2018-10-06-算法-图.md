---
layout: post
title: "第三篇：图"
description: "图"
categories: [算法]
tags: [算法, 图]
redirect_from:
  - /2018/10/06/
---

# 目录

* Kramdown table of contents
{:toc .toc}

# 正文

> 图由节点和边组成
> > 一个节点可能与众多节点直接相连，这些节点被称为邻居

![]({{ site.url }}/assets/shuzu_blog/graph_01.jpg){:height="50%" width="50%"}

# 图算法
## 一、广度优先搜索（BFS，breadth-first search)

> 是一种用于图数据的查找算法
>
> 用于解决两类问题
> > 第一类：从节点A出发，有前往节点B的路径吗
>
> > 第二类：从节点A出发，前往节点B的哪条路径最短

如何实现呢？

比如在上述A,B,C,D,E 构成的关系图中，想看A,E是否存在相通的道路，A,E如果相通，最短的路径是哪条。

让我们一度、二度依次来看（什么是一度、二度呢？我的朋友是一度，朋友的朋友是二度）

> A的一度朋友有B,C，添加到列单里 ==> {B,C}, B,C中都没有E, 因此接着看二度
> 
> B的一度朋友有D，添加到列表里 ==> {B,C,D}
>
> C的一度朋友有B,D，添加到列表里 ==> {B,C,D}
> 
> D的一度朋友有E， bingo

要用代码实现上述过程，首先应获取所有的关系数据，这种对应关系，散列表可以实现

	|--------+--------|
	|        |   B    |
	|    A   |--------|
	|        |   C    |
	|--------+--------|

~~~~~~~~~
graph = {}
graph['A']=['B','C']
graph['B']=['D']
graph['C']=['B','D']
graph['D']=['E']
graph['E']=[]
~~~~~~~~~

实现：通过构建一个搜索队列

![]({{ site.url }}/assets/graph/BFS_01.jpg)

代码实现：

> 首先创建一个队列，python中可使用deque创建了一个双端队列

~~~ python
from collections import deque
search_queue = deque()
search_queue += graph["you"]  # 将你的邻居都加入到这个搜索队列中
~~~

完善这个算法代码

~~~ python
while search_queue:                    # 只要队列不为空
	node = search_queue.popleft()      # 就取出其中的第一个人
	if node_is_E(node):                # 检查节点是否为E
		print("node %s is E")%node
		return True
	else:
		search_queue += graph(person)  # 不是节点E，将这个节点的邻居都加入搜索队列中
~~~

继续补充

~~~ python
def node_is_E(name):
	return name == 'E'
~~~

运行时间：O(V+E)  （补充）

拓扑排序：（补充）

广度优先搜索指出是否有从A到B的路径，如果有，广度优先搜索将找出最短路径。

## 二、深度优先算法

## 三、狄克斯特拉算法

> 找出加权图中前往X的最短路径

前面是根据图中边的个数去判断路径长短，如果边是有权重的呢？（也就是广度优先搜索，找出的是段数最少的路径，如果要找出最快的路径呢）

例如在汽车行驶过程中，两点之间的时间长短会受到距离长短和拥堵程度影响，因此不同点之间应该有相应的权重赋值。

例如下图的区别：

![]({{ site.url }}/assets/shuzu_blog/graph_02.jpg){:height="50%" width="50%"}

狄克斯特拉找到的是总权重最小的路径。

狄克斯特拉算法包含4个步骤：

以下图为例：

![]({{ site.url }}/assets/shuzu_blog/graph_03.jpg){:height="50%" width="50%"}

1、找出“最便宜”的节点，即可在最短时间内到达的节点

站在七点，不知道应该往节点A还是往节点B。假设前往节点A要6分钟，前往B要2分钟。由于不知道前往终点需要多长时间，因此假设为无穷大。从这个角度考虑，节点B最近，选择节点B

2、更新该节点的邻居开销

从节点B出发，计算经节点B前往其各个邻居所需的时间。发现！经B节点，前往A节点，需要5分钟，而直接前往A节点需要6分钟！

对于节点B的邻居，如果找到前往它的最短路径，就更新其开销： 在这里发现：

~ 前往节点A的更短路径（时间从6分钟缩短到5分钟）

~ 前往终点的更短路径（时间从无穷大缩短到7分钟）

3、重复这个过程，直到对图中的每个节点都这样做了

重复第一步：终点最短时间内前往的节点。前面已经对节点B执行了第二步，除节点B外，可在最短时间内前往的节点是节点A

重复第二步：更新节点A的所有邻居开销。发现前往终点的时间为6分钟。？？？

到目前为止，已经知道：

> 前往节点B需要2分钟
> 
> 前往节点A需要5分钟
>
> 前往终点需要6分钟

4、计算最终路径


其他：

狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重。

带权重的图称为加权图。不带权重的图称为非加权图。

图还有环，如下图：

![]({{ site.url }}/assets/shuzu_blog/graph_04.jpg){:height="50%" width="50%"}

有环就意味着，可以从一个节点出发，走一圈后又回到这个节点，

绕环前行是否合理呢？你可以选择避开环的路径，也可以选择包含环的路径。

这两条路径都可以到达终点，但环增加了权重，如果愿意，可绕环两次。但每绕环一次，总权重都增加8。因此，绕环的路径不可能是最短的路径

无向图意味着两个节点彼此指向对方，其实就是环。

![]({{ site.url }}/assets/shuzu_blog/graph_05.jpg){:height="50%" width="50%"}

在无向图中，每一条边都是一个环，迪克斯拉特算法只适用于有向无环图（directed acyclic graph, DAG）

《算法图解》中换钢琴的例子，第101页。感觉上面四个步骤，写成列表更清楚

![]({{ site.url }}/assets/shuzu_blog/graph_06.jpg){:height="50%" width="50%"}

![]({{ site.url }}/assets/shuzu_blog/graph_07.jpg){:height="50%" width="50%"}

上面知道最短路径的开销是35美元，但是如何确定这条路径呢？

首先找出钢琴的父节点：是架子鼓，架子鼓的父节点是唱片，唱片的父节点是乐谱。

由此，可以知道完整的交换路径是：乐谱 ==> 唱片 ==> 架子鼓 ==> 钢琴

> 负权边

有可能存在下面这种情况：

![]({{ site.url }}/assets/shuzu_blog/graph_08.jpg){:height="50%" width="50%"}

也就是边的权重是负的！

如果有负权边，就不能使用狄克斯特拉算法。原因见《算法图解》107页

因为狄克斯特拉算法的一个假设是：对于处理过的海报节点，没有前往该节点的更短路径。这一点也体现出为什么一个一个选最便宜的节点，这样的顺序重要性。

## 代码实现：

以下图为例：

![]({{ site.url }}/assets/shuzu_blog/graph_09.jpg){:height="50%" width="50%"}

解决上图这个问题，需要三个散列表。随着算法的进行，将不断更新散列表【开销表】和【父节点表】。

![]({{ site.url }}/assets/shuzu_blog/graph_10.jpg){:height="50%" width="50%"}

先将上面的图关系存进散列表中去（散列表中又包含散列表）

~~~
graph = {}
graph["start"] = {}
graph["start"]["a"] = 6
graph["start"]["b"] = 2

graph["a"] = {}
graph["a"]["fin"] = 1

graph["b"] = {}
graph["b"]["a"] = 3
graph["b"]["fin"] = 5

graph["fin"] = {}
~~~

接下来建立一个散列表存储每个节点的开销

~~~
infinity = float("inf")
costs = {}
costs["a"] = 6
costs["b"] = 2
costs["fin"] = infinity
~~~

还需要一个存储父节点的散列表

~~~
parents = {}
parents["a"] = "start"
parents["b"] = "start"
parents["fin"] = None
~~~ 

最后，需要一个数组，用于记录处理过的节点。

因为对于同一个节点，不用处理多次。

~~~
processed = []
~~~

算法过程如下：

![]({{ site.url }}/assets/shuzu_blog/graph_11.jpg){:height="50%" width="50%"}

代码如下：

~~~
node = find_lowest_cost_node(costs)  # 在未处理的节点中找出开销最小的节点
while node is not None:			     # 这个while循环在所有节点都被处理后结束
	cost = costs[node]
	neighbors = graph[node]
	for n in neighbors.keys():  #遍历当前节点的所有邻居
		new_cost = cost + neighbors[n]
		if costs[n] = new_cost:
			cost[n] = new_cost
			parents[n] = node
	processed.append(node)
	node = find_lowest_cost_node(costs)
	

# random walk

在node embedding里，有很多encode的方法，比如“shallow” encoding，Adjacency, Multi-hop, random walk.

![]({{ site.url }}/assets/graph/randomwalk_01.jpg){:height="50%" width="50%"}

其中需要理解的概念有：negative sampling。

如何进行随机游走呢？

最简单的方法有：固定长度，无偏的随机游走，从每个节点开始。

还可以，使用灵活的，有偏的随机游走，从局部和全局角度来划分，可以分成BFS和DFS，也是前面所说的广度优先算法和深度优先算法。node2vec

![]({{ site.url }}/assets/graph/randomwalk_02.jpg)

![]({{ site.url }}/assets/graph/randomwalk_03.jpg)

![]({{ site.url }}/assets/graph/randomwalk_04.jpg)

其他随机游走的方法还有：

不同类型的有偏随机游走：基于节点性质的，基于学习到的权重的。
其他优化方法：基于一跳二跳随机游走概率的优化
网络处理技术：基于修正后的网格进行随机游走。



随机游走矩阵可以看做是马尔科夫链的一种特例。

对于一个图G的邻接矩阵A来说，A中的非零元素描述了图G中每一条边的权重（这里一般要求A的对角线为0）。
这个权重描述了节点之间的相似性。如果我们对A进行按行归一化，即

D是A的度矩阵，是一个对角阵，对角线元素。这样得到的矩阵P就是一个随机游走矩阵。每个点与其他所有节点的跳转概率之和为1。

一个随机游走矩阵对应的是一个遍历的马尔科夫链，也就是说任意两个状态之间都可以互相到达。经过一步转移，下一时刻的概率为：

这样一直进行下去，经过一定时间可以到达稳态。所谓稳态，就是说状态的概率分布不再进行变化。
上述方程已经说明：稳态实际上就是随机游走矩阵，特征值1所对应的特征向量。另一种计算稳态的方法是：

马尔科夫链的基础矩阵定义为：

其中I是一个单位阵，P为对应的随机游走矩阵，W是将稳态按行堆叠形成的矩阵。

对于一个正规的马尔科夫链（即P的任何次方都没有负值的元素），W可以看做n趋于无穷大的情况。
通过基础矩阵，可以计算马尔科夫链的很多特性，其中主要包括了各种访问时间：

> 从状态i出发返回状态i的时间期望
>
> 从状态i出发，回到状态i之前，访问状态j的次数期望
>
> 从状态i出发，到达状态j的时间期望。
> 
> 从状态j出发，到达状态j之前，访问状态j的次数期望
>
> 从稳态出发，到达状态i的时间期望
>
> 从稳态出发，到达状态i之前，访问状态j的次数。

对应有三个定理：

> 对状态i
>
> 对状态j
>
> 对任意状态i
 


[^1]: 参考文献.
[1] 算法图解 Aditya Bhargava (作者) 袁国忠 (译者)