---
layout: post
title: "第三篇：图"
description: "图"
categories: [算法]
tags: [算法, 图]
redirect_from:
  - /2018/10/06/
---

# 目录

* Kramdown table of contents
{:toc .toc}

# 正文

> 图由节点和边组成
> > 一个节点可能与众多节点直接相连，这些节点被称为邻居

![]({{ site.url }}/assets/shuzu_blog/graph_01.jpg){:height="50%" width="50%"}

# 图算法
## 一、广度优先搜索（BFS，breadth-first search)

> 是一种用于图数据的查找算法
>
> 用于解决两类问题
> > 第一类：从节点A出发，有前往节点B的路径吗
>
> > 第二类：从节点A出发，前往节点B的哪条路径最短

如何实现呢？

比如在上述A,B,C,D,E 构成的关系图中，想看A,E是否存在相通的道路，A,E如果相通，最短的路径是哪条。

让我们一度、二度依次来看（什么是一度、二度呢？我的朋友是一度，朋友的朋友是二度）

> A的一度朋友有B,C，添加到列单里 ==> {B,C}, B,C中都没有E, 因此接着看二度
> 
> B的一度朋友有D，添加到列表里 ==> {B,C,D}
>
> C的一度朋友有B,D，添加到列表里 ==> {B,C,D}
> 
> D的一度朋友有E， bingo

要用代码实现上述过程，首先应获取所有的关系数据，这种对应关系，散列表可以实现

	|--------+--------|
	|        |   B    |
	|    A   |--------|
	|        |   C    |
	|--------+--------|

~~~~~~~~~
graph = {}
graph['A']=['B','C']
graph['B']=['D']
graph['C']=['B','D']
graph['D']=['E']
graph['E']=[]
~~~~~~~~~

实现：通过构建一个搜索队列

![]({{ site.url }}/assets/graph/BFS_01.jpg)

代码实现：

> 首先创建一个队列，python中可使用deque创建了一个双端队列

~~~ python
from collections import deque
search_queue = deque()
search_queue += graph["A"]  # 将A的邻居都加入到这个搜索队列中
~~~

完善这个算法代码

~~~ python
while search_queue:                    # 只要队列不为空
	node = search_queue.popleft()      # 就取出其中的第一个人
	if node_is_E(node):                # 检查节点是否为E
		print("node %s is E")%node
		return True
	else:
		search_queue += graph(person)  # 不是节点E，将这个节点的邻居都加入搜索队列中
~~~

继续补充

~~~ python
def node_is_E(name):
	return name == 'E'
~~~

接下来看广义优先搜索的执行过程：

![]({{ site.url }}/assets/graph/BFS_02.jpg)

上面可以看到，检查了D两次，其实是没有意义的。因此应该将其标记为已检查。

从而完整的BFS代码为

~~~ python 
def search(name):
	search_queue = deque()
	search_queue += graph[name]
	searched = []
	while search_queue:
		node = search_queue.popleft()
		if node not in searched:
			if node_is_E(node):
				print('bingo')
				return True
			else:
				search_queue += graph[node]
				searched.append(node)
	return False
~~~

运行时间：O(V+E) 

> 上面这个例子意味着A将沿每条边前行，因此运行时间至少为O(边数)。
>
> 还使用了一个队列，其中包含要检查的每个节点。将一个节点添加到队列需要的时间是固定的，即O(1)。因此对每个节点都这样做，需要的总时间是O(节点数)
>
> 所以广度优先搜索的运行时间为O(边数+节点数），通常写作O(V+E)

其他不错的例子：

![]({{ site.url }}/assets/graph/BFS_03.jpg)

![]({{ site.url }}/assets/graph/BFS_04.jpg)

![]({{ site.url }}/assets/graph/BFS_05.jpg)

![]({{ site.url }}/assets/graph/BFS_06.jpg)


拓扑排序：

> 根据图创新的列表是有序的。如果任务A依赖于任务B，在列表中任务A就必须在任务B后面。这被称之为**拓扑排序**
>
> 使用它可根据图创建一个有序列表。
>
> > 假设你正在规划一场婚礼，并有一个很大的图，其中充斥着需要做的事情，但却不知道要从哪里开始。这时就可以使用拓扑排序来创建一个有序的任务列表。
> > 
> > 还有一个例子是家谱，家谱图只有向下没有向上的箭头，这种图又称之为树。


广度优先搜索指出是否有从A到B的路径，如果有，广度优先搜索将找出最短路径。

## Deepwalk

> 利用构造节点在网络上的随机游走，来模仿文本生成的过程，提供一个节点序列。
>
> 然后用skip-gram和Hierarchical softmax模型，对随机游走序列的每个局部窗口内的节点进行概率建模。
>
> 最大化随机游走序列的似然概率，并使用最终随机梯度下降学习参数，进而产生图的节点的嵌入表示。
> 
> 一般是针对图中的每个节点v属于V，产生N个长度为l的随机游走序列，然后用合适的窗口w去采样抽取其中的节点特征。

Deepwalk选取随机游走序列中的下一个节点的方式是**均匀随机分布**的。

## node2vec

> 与deepwalk不同，n2v选取随机游走序列中下一个节点的方式不是均匀随机分布，而是引入两个参数p和q
>
> 将宽度优先搜索和深度优先搜索引入随机游走序列的生成过程。
> > 宽度有限搜索（BFS）注重临近的节点，并刻画了相对局部的一种网络表示  p  局部微观结构
> > 
> > 深度优先搜索（DFS）反应了更高层面上的节点间的同质性。  q  全局宏观结构
> BFS能够探究图中的结构性质，DFS能够探究出内容上的相似性（相邻节点之间的相似性）
>
> 其中结构相似性不一定要相连接，甚至可能相距很远。

![]({{ site.url }}/assets/graph/n2v_01.jpg)

如上图所示：t是v的上一个节点，x1，x2，x3是v的下一个节点。

> 那么返回上一个节点t的概率是1/p，
>
> x1离t的距离和v离t的距离相同，因此进入节点x1的概率是1
>
> x2和x3是v的下一个节点，进入的概率是1/q

n2v根据p和q定义了不同的邻居的跳转概率，p控制着跳向上一个节点的邻居的概率，q控制着跳向上一个节点的非邻居的概率

即，p是控制访问走过的node，即往回走；q是控制访问还没有走过的node，即向外走。

写成公式即：

![]({{ site.url }}/assets/graph/n2v_02.jpg)

n2v通过半监督形式，利用网络搜索最适合的参数学习节点表示。

![]({{ site.url }}/assets/graph/n2v_03.jpg)

特别是，在网络节点上的预测任务往往在两种相似点之间穿梭：**同质性和结构等价性**。

> 在同质性假设下：高度互联且属于相似网络集群或社区的节点应紧密嵌入在一起（例如上图的节点s1和u属于同一网络社区）
>
> 在结构等价性的假设下，在网络中具有相似结构作用的节点应该紧密地嵌入在一起（例如上图中的节点u和s6作为其相应社区的枢纽）
>
> 与同质性不同，结构等价性不强调连通性；节点可以在网络中相隔很远，并且仍然具有相同的结构角色。
>
> 在现实世界中，这些等价概念并不是唯一的； 网络通常表现出两种行为，其中一些节点表现出同质性，而另一些反映出结构等价性。



## 二、深度优先算法



## 三、狄克斯特拉算法

> 找出加权图中前往X的最短路径

前面是根据图中边的个数去判断路径长短，如果边是有权重的呢？（也就是广度优先搜索，找出的是段数最少的路径，如果要找出最快的路径呢）

例如在汽车行驶过程中，两点之间的时间长短会受到距离长短和拥堵程度影响，因此不同点之间应该有相应的权重赋值。

例如下图的区别：

![]({{ site.url }}/assets/shuzu_blog/graph_02.jpg){:height="50%" width="50%"}

狄克斯特拉找到的是总权重最小的路径。

狄克斯特拉算法包含4个步骤：

以下图为例：

![]({{ site.url }}/assets/shuzu_blog/graph_03.jpg){:height="50%" width="50%"}

1、找出“最便宜”的节点，即可在最短时间内到达的节点

站在七点，不知道应该往节点A还是往节点B。假设前往节点A要6分钟，前往B要2分钟。由于不知道前往终点需要多长时间，因此假设为无穷大。从这个角度考虑，节点B最近，选择节点B

2、更新该节点的邻居开销

从节点B出发，计算经节点B前往其各个邻居所需的时间。发现！经B节点，前往A节点，需要5分钟，而直接前往A节点需要6分钟！

对于节点B的邻居，如果找到前往它的最短路径，就更新其开销： 在这里发现：

~ 前往节点A的更短路径（时间从6分钟缩短到5分钟）

~ 前往终点的更短路径（时间从无穷大缩短到7分钟）

3、重复这个过程，直到对图中的每个节点都这样做了

重复第一步：终点最短时间内前往的节点。前面已经对节点B执行了第二步，除节点B外，可在最短时间内前往的节点是节点A

重复第二步：更新节点A的所有邻居开销。发现前往终点的时间为6分钟。？？？

到目前为止，已经知道：

> 前往节点B需要2分钟
> 
> 前往节点A需要5分钟
>
> 前往终点需要6分钟

4、计算最终路径


其他：

狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重。

带权重的图称为加权图。不带权重的图称为非加权图。

图还有环，如下图：

![]({{ site.url }}/assets/shuzu_blog/graph_04.jpg){:height="50%" width="50%"}

有环就意味着，可以从一个节点出发，走一圈后又回到这个节点，

绕环前行是否合理呢？你可以选择避开环的路径，也可以选择包含环的路径。

这两条路径都可以到达终点，但环增加了权重，如果愿意，可绕环两次。但每绕环一次，总权重都增加8。因此，绕环的路径不可能是最短的路径

无向图意味着两个节点彼此指向对方，其实就是环。

![]({{ site.url }}/assets/shuzu_blog/graph_05.jpg){:height="50%" width="50%"}

在无向图中，每一条边都是一个环，迪克斯拉特算法只适用于有向无环图（directed acyclic graph, DAG）

《算法图解》中换钢琴的例子，第101页。感觉上面四个步骤，写成列表更清楚

![]({{ site.url }}/assets/shuzu_blog/graph_06.jpg){:height="50%" width="50%"}

![]({{ site.url }}/assets/shuzu_blog/graph_07.jpg){:height="50%" width="50%"}

上面知道最短路径的开销是35美元，但是如何确定这条路径呢？

首先找出钢琴的父节点：是架子鼓，架子鼓的父节点是唱片，唱片的父节点是乐谱。

由此，可以知道完整的交换路径是：乐谱 ==> 唱片 ==> 架子鼓 ==> 钢琴

> 负权边

有可能存在下面这种情况：

![]({{ site.url }}/assets/shuzu_blog/graph_08.jpg){:height="50%" width="50%"}

也就是边的权重是负的！

如果有负权边，就不能使用狄克斯特拉算法。原因见《算法图解》107页

因为狄克斯特拉算法的一个假设是：对于处理过的海报节点，没有前往该节点的更短路径。这一点也体现出为什么一个一个选最便宜的节点，这样的顺序重要性。

## 代码实现：

以下图为例：

![]({{ site.url }}/assets/shuzu_blog/graph_09.jpg){:height="50%" width="50%"}

解决上图这个问题，需要三个散列表。随着算法的进行，将不断更新散列表【开销表】和【父节点表】。

![]({{ site.url }}/assets/shuzu_blog/graph_10.jpg){:height="50%" width="50%"}

先将上面的图关系存进散列表中去（散列表中又包含散列表）

~~~
graph = {}
graph["start"] = {}
graph["start"]["a"] = 6
graph["start"]["b"] = 2

graph["a"] = {}
graph["a"]["fin"] = 1

graph["b"] = {}
graph["b"]["a"] = 3
graph["b"]["fin"] = 5

graph["fin"] = {}
~~~

接下来建立一个散列表存储每个节点的开销

~~~
infinity = float("inf")
costs = {}
costs["a"] = 6
costs["b"] = 2
costs["fin"] = infinity
~~~

还需要一个存储父节点的散列表

~~~
parents = {}
parents["a"] = "start"
parents["b"] = "start"
parents["fin"] = None
~~~ 

最后，需要一个数组，用于记录处理过的节点。

因为对于同一个节点，不用处理多次。

~~~
processed = []
~~~

算法过程如下：

![]({{ site.url }}/assets/shuzu_blog/graph_11.jpg){:height="50%" width="50%"}

代码如下：

~~~ python
node = find_lowest_cost_node(costs)  # 在未处理的节点中找出开销最小的节点
while node is not None:			     # 这个while循环在所有节点都被处理后结束
	cost = costs[node]
	neighbors = graph[node]
	for n in neighbors.keys():  #遍历当前节点的所有邻居
		new_cost = cost + neighbors[n]
		if costs[n] = new_cost:
			cost[n] = new_cost
			parents[n] = node
	processed.append(node)
	node = find_lowest_cost_node(costs)
~~~ 

# 随机游走 random walk

一般提及的随机游走是指DeepWalk中的随机游走，选择下一步节点是随机的。

除此之外还有node2vec中的2nd order随机游走。随机游走下一步的选择不是均匀的随机的，而是有偏的。

在node embedding里，有很多encode的方法，比如“shallow” encoding，Adjacency, Multi-hop, random walk.

![]({{ site.url }}/assets/graph/randomwalk_01.jpg){:height="50%" width="50%"}

其中需要理解的概念有：negative sampling。

如何进行随机游走呢？

最简单的方法有：固定长度，无偏的随机游走，从每个节点开始。

还可以，使用灵活的，有偏的随机游走，从局部和全局角度来划分，可以分成BFS和DFS，也是前面所说的广度优先算法和深度优先算法。node2vec

![]({{ site.url }}/assets/graph/randomwalk_02.jpg)

![]({{ site.url }}/assets/graph/randomwalk_03.jpg)

![]({{ site.url }}/assets/graph/randomwalk_04.jpg)

其他随机游走的方法还有：

不同类型的有偏随机游走：基于节点性质的，基于学习到的权重的。
其他优化方法：基于一跳二跳随机游走概率的优化
网络处理技术：基于修正后的网格进行随机游走。


随机游走的公式：


随机游走的优点：
>1，只依赖于局部信息，所以可适用于分布式和在线系统，而使用邻接矩阵就必须把所有信息存储于内存中处理，面临着较高的计算时间和空间消耗
>
>2，对随机游走序列进行建模可以降低建模0-1二值邻接矩阵的方差和不确定性





随机游走矩阵可以看做是马尔科夫链的一种特例。

对于一个图G的邻接矩阵A来说，A中的非零元素描述了图G中每一条边的权重（这里一般要求A的对角线为0）。
这个权重描述了节点之间的相似性。如果我们对A进行按行归一化，即

D是A的度矩阵，是一个对角阵，对角线元素。这样得到的矩阵P就是一个随机游走矩阵。每个点与其他所有节点的跳转概率之和为1。

一个随机游走矩阵对应的是一个遍历的马尔科夫链，也就是说任意两个状态之间都可以互相到达。经过一步转移，下一时刻的概率为：

这样一直进行下去，经过一定时间可以到达稳态。所谓稳态，就是说状态的概率分布不再进行变化。
上述方程已经说明：稳态实际上就是随机游走矩阵，特征值1所对应的特征向量。另一种计算稳态的方法是：

马尔科夫链的基础矩阵定义为：

其中I是一个单位阵，P为对应的随机游走矩阵，W是将稳态按行堆叠形成的矩阵。

对于一个正规的马尔科夫链（即P的任何次方都没有负值的元素），W可以看做n趋于无穷大的情况。
通过基础矩阵，可以计算马尔科夫链的很多特性，其中主要包括了各种访问时间：

> 从状态i出发返回状态i的时间期望
>
> 从状态i出发，回到状态i之前，访问状态j的次数期望
>
> 从状态i出发，到达状态j的时间期望。
> 
> 从状态j出发，到达状态j之前，访问状态j的次数期望
>
> 从稳态出发，到达状态i的时间期望
>
> 从稳态出发，到达状态i之前，访问状态j的次数。

对应有三个定理：

> 对状态i
>
> 对状态j
>
> 对任意状态i
 


[^1]: 参考文献.
[1] 算法图解 Aditya Bhargava (作者) 袁国忠 (译者)