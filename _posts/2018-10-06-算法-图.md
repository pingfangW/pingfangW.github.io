---
layout: post
title: "第三篇：图"
description: "图"
categories: [算法]
tags: [算法, 图]
redirect_from:
  - /2018/10/06/
---

# 目录

* Kramdown table of contents
{:toc .toc}

# 正文

> 图由节点和边组成
> > 一个节点可能与众多节点直接相连，这些节点被称为邻居

![]({{ site.url }}/assets/shuzu_blog/graph_01.jpg){:height="50%" width="50%"}

# 图算法 - 广度优先搜索

> 是一种用于图数据的查找算法
>
> 用于解决两类问题
> > 第一类：从节点A出发，有前往节点B的路径吗
>
> > 第二类：从节点A出发，前往节点B的哪条路径最短

如何实现呢？

比如在上述A,B,C,D,E 构成的关系图中，想看A,E是否存在相通的道路，A,E如果相通，最短的路径是哪条。

让我们一度、二度依次来看（什么是一度、二度呢？我的朋友是一度，朋友的朋友是二度）

> A的一度朋友有B,C，添加到列单里 ==> {B,C}, B,C中都没有E, 因此接着看二度
> 
> B的一度朋友有D，添加到列表里 ==> {B,C,D}
>
> C的一度朋友有B,D，添加到列表里 ==> {B,C,D}
> 
> D的一度朋友有E， bingo

要用代码实现上述过程，首先应获取所有的关系数据，这种对应关系，散列表可以实现

	|--------+--------|
	|        |   B    |
	|    A   |--------|
	|        |   C    |
	|--------+--------|

~~~~~~~~~
graph = {}
graph['A']=['B','C']
graph['B']=['D']
graph['C']=['B','D']
graph['D']=['E']
graph['E']=[]
~~~~~~~~~

实现：通过构建一个搜索队列（补充）

运行时间：O(V+E)  （补充）

拓扑排序：（补充）



[^1]: 参考文献.
[1] 算法图解 Aditya Bhargava (作者) 袁国忠 (译者)