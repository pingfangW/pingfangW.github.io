---
layout: post
title: "第三篇：排序"
description: "快速排序、简单排序"
categories: [算法]
tags: [算法, 排序]
redirect_from:
  - /2018/10/06/
---

# 目录

* Kramdown table of contents
{:toc .toc}

# 一、选择排序

> 选择排序是一种排序算法
> > 浏览一遍所有数据，从里面挑出最大的，再浏览一遍，挑出第二大的，如果有n个元素，那么要浏览N变，每次都要浏览N个元素
> 因此是O(n^2)

如下图：

![]({{ site.url }}/assets/shuzu_blog/sort_01.jpg){:height="50%" width="50%"}

显然这属于比较笨的那一种算法，有人问，每次都可以少浏览一个元素啊。为什么不是n，n-1，n-2，...，1

这样运行时间不就少了吗？如果是这样，平均来看，每次浏览n/2，那么就是O(n^2/2)，考虑之前提及一般会省略常数。

# 二、快速排序

刚才的排序方法笨笨的，这里介绍一个快一些的算法

用简单查询 vs 二分查询一样。一个一个来总是最笨的，可以选择分批处理，快速排序也是大致思路。

## 步骤

1. 首先选择一个基准值

2. 接下来对两边的子数组进行排序，同样是拆分

具体从笔记本上再整理。

想法很简单，如何实现呢？

整个是一个重复过程，可以通过递归，见递归那一章

那么快速排序速度有多快呢？

如果每次基准值都是第一个，那要把所有元素都过一遍 ==> O(n) ==> O(n*n)，如果从中间选，则一半一半，==> O(logn) ==> O(n*logn)

# 三、合并排序







[^1]: 参考文献.
[1] 算法图解 Aditya Bhargava (作者) 袁国忠 (译者)