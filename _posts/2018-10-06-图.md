---
layout: post
title: "图"
description: "图"
categories: [机器学习]
tags: [机器学习]
comments: true
---
# 目录：

* Kramdown table of contents
{:toc .toc}

# 正文：

## 什么是图

在数学上，图（Graph）是表示对象与对象之间关系的方法。

从定义上可以看出，图有两个要素：

1、对象又称节点（Node）、顶点（Vertex）、实体（Entity），它描述的是具体的一件事物。

2、关系又称边（edge）它描述的对象之间的关系。

我们一般用这样的形式来表示一张图：G=(V, E), V表示节点的集合，E表示边集合；

![]({{ site.url }}/assets/images/graph/graph_08.jpg)

V={V0,V1,V2,V3}、E={V0V1,V0V2,V1V2,V1V3}

![]({{ site.url }}/assets/images/graph/graph_09.jpg)

图的另一种表达方式是邻接矩阵（Adjacent matrix）

$$A_{ij}$$(邻接矩阵的第i行第j列)的取值表示的是第i个节点与第j个节点之间是否有边，取值为1表示有边，取值为0表示无边。邻接矩阵刻画的是图的结构信息，给定一个邻接矩阵，相应的图就可以画出来。


另外在实际研究中，节点与边都有特定的类型，比如连接“用户”与“商品”节点的边，很可能就是“购买”的类型关系。

像这样，在构建一个具体业务场景的图时，标识上节点类型与边的类型，这样的图我们称之为图的结构表示（Graph Schema），

它反应出来的是一种业务上的逻辑抽取。后面我们会结合各类现实场景中的Graph Schema来说说我们关注的一些学习任务。




图做为一种广泛应用的数据结构，其优势主要表现在两点：

一是顺藤摸瓜，给定一个节点，顺着其边的信息，能够快速的找到它的邻居节点。换言之，在图里面查询信息很容易。


二是拉帮结派，由于图的传播性强（邻居的邻居也跟自己关系紧密），相互之间联系紧密的节点可以构成一个子图（或子团）。

![]({{ site.url }}/assets/images/graph/graph_10.jpg)

上图中可以明显看到有a、b两个子图，一般像这样在图中寻找子团的任务称为社群检测（Community Detection ）或者叫作高密子图挖掘（Dense Subgraph Mining）。


现实场景下缤纷的图世界：

社交网络

![]({{ site.url }}/assets/images/graph/graph_11.jpg)

利用社交网络图可以实现以下任务：

1、推荐用户可能感兴趣的人；

2、推荐用户可能感兴趣的帖子或者内容；

3、社群发现（通过用户社交关系网络挖掘群体结构）；

4、用户画像（地点、兴趣、关系网络）；

搜索排名

![]({{ site.url }}/assets/images/graph/graph_12.jpg)

图在网页排名中的应用，根据各网页的链接关系网来确定各网页的排名，又叫做PageRank算法。其基本思路是被引用越多的网页重要性越高；被重要性高的网页链接的网页重要性越高。

评分系统

![]({{ site.url }}/assets/images/graph/graph_13.jpg)

用户-产品的评分图

通过上述的图可以分析比如哪些用户可能对啤酒感兴趣，哪些用户可能对尿布感兴趣，从而实现商品推荐。还可以实现评分清洗，建模用户的公平度、商品的良心度、评分的可信度，按照一定的规则迭代更新这三个值，从而分析商品的优劣或者区分恶意用户。例如上图中的用户f，很大可能就是恶意评价用户。

推荐系统

![]({{ site.url }}/assets/images/graph/graph_14.jpg)


用户与歌曲的关系图谱，可以实现可解释的推荐和精细化推荐。

比如沿着用户-歌曲-曲风-歌曲这个路径是推荐用户喜欢的曲风下的其他歌曲；沿着用户-年代-歌曲-歌手是推荐活跃在用户出生年代的歌手的歌曲（可能是用户小时候听过的歌，俗称回忆杀系列），这些就是可解释的推荐。

小思考：沿着用户-歌曲-年代-用户-歌曲的意义是什么呢？

关于精细化推荐，从图中挖掘有很多条路径，很多种理由去推荐，每个用户对具体路径的偏好不一，我们还可以根据历史偏好信息对用户做更精细化的推荐。

## 知识图谱（关联图谱）

知识图谱通常是指从文本中分解实体及其关系，导入到图中，便于查询及推理。简单介绍两个很简单的知识图谱应用。

▪知识图谱应用之知识推理：

![]({{ site.url }}/assets/images/graph/graph_15.jpg)

基于规则“爸爸的爸爸是爷爷”可以推理出康熙是乾隆的爷爷。

▪知识图谱应用之语义理解（智能问答）：

![]({{ site.url }}/assets/images/graph/graph_16.jpg)

通过对“北京”和“博物馆”两个信息的综合，机器可以得出结论该地方很有可能是指故宫。

风险控制

图在风控中的应用很广泛，很多风控的策略逻辑可以转化为图里面的一些具体问题来思考。比如下面涉及到的几种思路方法，包括像关联识别、聚类识别、推导识别、异构识别、碰撞识别等一系列应用。

▪风险控制之关联识别

通过强标识性节点的关联信息来做Identity recognition。比如关联到相同设备指纹与IP节点的用户可视为同一用户。

![]({{ site.url }}/assets/images/graph/graph_17.jpg)

短时间内关联到同一设备节点的用户节点数目异常可考虑为撞库行为。

![]({{ site.url }}/assets/images/graph/graph_18.jpg)

同一设备关联的用户数目异常

![]({{ site.url }}/assets/images/graph/graph_19.jpg)

撞库原理

## ▪风险控制之聚类识别

通过节点关联信息来挖掘子图结构，而这种致密的结构通常会被判定为异常的风险关系。

图中可以看出，用户1、用户2、用户3和帖子1、帖子2形成了高密子图

▪风险控制之推导识别

顺藤摸瓜，找到与异常节点相关联的节点进行风险排查。

![]({{ site.url }}/assets/images/graph/graph_20.jpg)

▪风险控制之异构识别：

用户关联的信息发生较大变化，潜在被盗号风险。

▪风险控制之碰撞识别：

![]({{ site.url }}/assets/images/graph/graph_21.jpg)

节点之间的对应关系出现碰撞矛盾。

公司G同时存在两个地址，出现数据碰撞，那么就可能有风险。


## 归纳总结：图的学习任务分类

上面和大家介绍的是一些常见场景下的图结构以及相关任务，总的来说，我们可以从节点、边、图三个方面对图学习任务进行分类。

1、节点上的任务：利用图中节点的关系可以做包括分类（比如风险识别、价值排名等任务）、聚类（社群检测、用户画像等任务）。

2、边上的任务：通过图中节点之间是否有边可以做比如推荐、知识推理等任务。

3、图上的任务：图可以做像高分子分类、3D视觉分类等任务。

在后期专栏中将会对各种任务进行更加细致的探讨。图在各种场景数据中都有着广泛的适用性。但是实际应用上，图的学习一直停留在“规则引擎”、“图计算”这样的浅层层面上，本专栏旨在通过梳理 Graph learning的方方面面，和大家一起打开思路，探讨真正的 Learning on graph。

## 同构图

假设G=(V,E)和G1=(V1,E1)是两个图。

如果存在一个双射m：V->V1，

使得【对所有x,y∈V，均有xy∈E】等价于【m(x)m(y)∈E1】，则称G和G1是同构的，

这的一个映射m称之为一个同构

如果G=G1，则称他为一个自同构

> 简单来说，同构图的结点数必须相同，结构必须相同

![]({{ site.url }}/assets/images/graph/graph_01.jpg)

上图是一组同构图。

![]({{ site.url }}/assets/images/graph/graph_02.jpg)

![]({{ site.url }}/assets/images/graph/graph_03.jpg)

　　
简单来说，同构图的结点数必须相同，结构必须相同。

如图3.6，第一个图形和第二个图形的区别在于环的数量。第一个图形为一个环，第二个为两个环，所以不是同构图。

若删去z1和u1，删去v1和w1，连接z1和w1，成为一个v1u1的链和z1w1x1y1的环，依旧不是同构图，因为必须环数相同，链数相同。

但这还是缺少一个条件，比如图形A存在两个环a1和a2，a1有3个结点，a2有5个结点，图形B也有两个环，b1有4个结点，b2有4个结点，依旧不是同构图，这里的条件就是环上或链上的借点数相同，和结点顺序无关。


判断两次组成的图形是否是同构图。

思路之一：通过并查集确定环数/链数，和环内/链内的人数，再排序进行比较。

排序时按照人数排序，若人数相同要按照状态排序。注意这几点或许会比较容易过。

请先自己进行尝试，尝试后再参考代码。


 1     #include<iostream>  
 2     #include<cstring>  
 3     #include<cstdio>  
 4     #include<math.h>  
 5     #include<vector>  
 6     #include<algorithm>  
 7     #include<queue>  
 8     #include<set>  
 9     using namespace std;  
10     int pre[10100];  
11     struct e{  
12         int a,b;  
13     };  
14     e s1[10010];  
15     e s2[10010];  
16     int find(int x)  
17     {  
18         while(x!=pre[x])  
19             x=pre[x];  
20         return x;  
21     }  
22     int cmp(e a,e b){  
23         if(a.a==b.a) return a.b>b.b;  
24         else return a.a>b.a;  
25     }  
26     void init(int n)  
27     {  
28         for(int i=1;i<=n;i++)  
29             pre[i]=i;  
30     }  
31     int main()  
32     {  
33         int t,cas=1;;  
34         scanf("%d",&t);  
35         while(t--)  
36         {  
37             for(int i=1;i<10010;i++)  
38             {  
39                 s1[i].a=1;s1[i].b=0;  
40                 s2[i].a=1;s2[i].b=0;//最开始每个都是独立的，默认为链  
41             }  
42             bool flag=false;  
43             int n1,m1,n2,m2;  
44       
45             scanf("%d%d",&n1,&m1);  
46             init(n1);  
47             for(int i=0;i<m1;i++)  
48             {  
49                 int a,b;  
50                 scanf("%d%d",&a,&b);  
51                 int dx=find(a);  
52                 int dy=find(b);  
53                 if(dx!=dy)  
54                 {  
55                     pre[dx]=dy;  
56                     s1[dy].a+=s1[dx].a;  
57                     s1[dx].a=0;//把拉手的孩子数量加起来，下同  
58                 }  
59                 else s1[dy].b=1;//成环  
60             }  
61       
62             scanf("%d%d",&n2,&m2);  
63             init(n2);  
64             for(int i=0;i<m2;i++)  
65             {  
66                 int a,b;  
67                 scanf("%d%d",&a,&b);  
68                 int dx=find(a);  
69                 int dy=find(b);  
70                 if(dx!=dy)  
71                 {  
72                     pre[dx]=dy;  
73                     s2[dy].a+=s2[dx].a;  
74                     s2[dx].a=0;  
75                 }  
76                 else s2[dy].b=1;  
77             }  
78             if(n1==n2){  
79       
80             sort(s1+1,s1+n1+1,cmp);  
81             sort(s2+1,s2+n2+1,cmp);//排序，若孩子的数量相同则对是否是环进行排序，这里要注意  
82       
83                 for(int i=0;i<n1;i++)  
84                 if(s1[i].a!=s2[i].a||s1[i].b!=s2[i].b) {//判断数量，状态  
85                     flag=true;  
86                     break;  
87                 }  
88             }  
89             if(n1!=n2)    flag=true;  
90       
91             if(flag) printf("Case #%d: NO\n",cas++);  
92             else printf("Case #%d: YES\n",cas++);  
93         }  
94         return 0;  
95     }  



参考文献：

http://www.cnblogs.com/ECJTUACM-873284962/p/6864324.html

https://mp.weixin.qq.com/s/HXrgspqv71QnaFrWSR1rBw